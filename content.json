{"meta":{"title":"Ding  Blog","subtitle":null,"description":null,"author":"DingJian","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2016-12-14T05:49:08.000Z","updated":"2016-12-14T08:12:52.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一只学习前端的小菜鸟，在此记录前端学习之路的点点滴滴"},{"title":"categories","date":"2016-12-14T05:33:22.000Z","updated":"2016-12-14T05:48:18.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-12-14T02:38:17.000Z","updated":"2016-12-14T02:38:58.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-12-14T05:33:22.000Z","updated":"2016-12-14T05:48:18.000Z","comments":true,"path":"photos/index.html","permalink":"http://yoursite.com/photos/index.html","excerpt":"","text":""}],"posts":[{"title":"阅读jQuery源码","slug":"阅读jQuery源码","date":"2017-08-18T16:34:48.000Z","updated":"2017-08-19T03:56:53.478Z","comments":true,"path":"2017/08/19/阅读jQuery源码/","link":"","permalink":"http://yoursite.com/2017/08/19/阅读jQuery源码/","excerpt":"一直听说jQuery的设计优雅巧妙，尽管现在的工作中大多使用MVVM框架，如VUE、React,但是jQuery仍然是经常可以使用到的工具库。决定花一段时间研究一下jQuery的源码，在此记录一下自己的理解以及感悟。","text":"一直听说jQuery的设计优雅巧妙，尽管现在的工作中大多使用MVVM框架，如VUE、React,但是jQuery仍然是经常可以使用到的工具库。决定花一段时间研究一下jQuery的源码，在此记录一下自己的理解以及感悟。 jQuery的架构链式调用jQuery的链式调用十分优雅，如$(&#39;div&#39;).css()，看了源码终于知道它是怎么实现的了。在使用$()的时候，会返回一个构造函数jQuery.fn.init()创建的实例,而这个实例的prototype又指向$的prototype,所以我们$()后返回的实现可以调用jQuery.prototype上面的所有方法。 123456789101112131415161718192021(function(window, undefined)&#123;var jQuery = function() &#123; return new jQuery.fn.init();&#125;jQuery.fn = jQuery.prototype = &#123; constructor: jQuery, init: function() &#123; return this &#125;, hello: function() &#123; alert(\"hello jquery\") &#125;&#125;jQuery.fn.init.prototype = jQuery.fn;window.jQuery = window.$ = jQuery;&#125;)(window)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"CSS三栏布局","slug":"CSS三栏布局","date":"2017-08-13T07:43:48.000Z","updated":"2017-08-17T13:19:20.398Z","comments":true,"path":"2017/08/13/CSS三栏布局/","link":"","permalink":"http://yoursite.com/2017/08/13/CSS三栏布局/","excerpt":"三栏布局在平常开发111中也是非常常见的，在这里总结一下左右固定，中间自适应的三栏布局的几种方法。默认高度固定为200px,左右宽度固定为300px","text":"三栏布局在平常开发111中也是非常常见的，在这里总结一下左右固定，中间自适应的三栏布局的几种方法。默认高度固定为200px,左右宽度固定为300px 浮动float12345678910111213141516171819202122232425&lt;section class=\"layout float\"&gt; &lt;style media=\"screen\"&gt; .layout.float .left&#123; float:left; width:300px; background: red; &#125; .layout.float .center&#123; background: yellow; &#125; .layout.float .right&#123; float:right; width:300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=\"left-right-center\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;浮动解决方案&lt;/h2&gt; &lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 绝对定位123456789101112131415161718192021222324252627282930&lt;section class=\"layout absolute\"&gt; &lt;style&gt; .layout.absolute .left-center-right&gt;div&#123; position: absolute; &#125; .layout.absolute .left&#123; left:0; width: 300px; background: red; &#125; .layout.absolute .center&#123; left: 300px; right: 300px; background: yellow; &#125; .layout.absolute .right&#123; right:0; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;绝对定位解决方案&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; flexbox123456789101112131415161718192021222324252627282930&lt;section class=\"layout flexbox\"&gt; &lt;style&gt; .layout.flexbox&#123; margin-top: 110px; &#125; .layout.flexbox .left-center-right&#123; display: flex; &#125; .layout.flexbox .left&#123; width: 300px; background: red; &#125; .layout.flexbox .center&#123; flex:1; background: yellow; &#125; .layout.flexbox .right&#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;flexbox解决方案&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 表格12345678910111213141516171819202122232425262728293031&lt;section class=\"layout table\"&gt; &lt;style&gt; .layout.table .left-center-right&#123; width:100%; height: 100px; display: table; &#125; .layout.table .left-center-right&gt;div&#123; display: table-cell; &#125; .layout.table .left&#123; width: 300px; background: red; &#125; .layout.table .center&#123; background: yellow; &#125; .layout.table .right&#123; width: 300px; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;表格布局解决方案&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt; 网格1234567891011121314151617181920212223242526272829303132&lt;section class=\"layout grid\"&gt; &lt;style&gt; .layout.grid .left-center-right&#123; width:100%; display: grid; grid-template-rows: 100px; grid-template-columns: 300px auto 300px; &#125; .layout.grid .left-center-right&gt;div&#123; &#125; .layout.grid .left&#123; width: 300px; background: red; &#125; .layout.grid .center&#123; background: yellow; &#125; .layout.grid .right&#123; background: blue; &#125; &lt;/style&gt; &lt;h1&gt;三栏布局&lt;/h1&gt; &lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;网格布局解决方案&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/article&gt;&lt;/section&gt;","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"CSS布局","slug":"CSS布局","permalink":"http://yoursite.com/tags/CSS布局/"}]},{"title":"windos常用软件工具个人配置","slug":"windos常用软件工具个人配置","date":"2017-08-13T03:46:25.000Z","updated":"2017-08-13T07:42:18.304Z","comments":true,"path":"2017/08/13/windos常用软件工具个人配置/","link":"","permalink":"http://yoursite.com/2017/08/13/windos常用软件工具个人配置/","excerpt":"","text":"","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"软件工具","slug":"软件工具","permalink":"http://yoursite.com/tags/软件工具/"}]},{"title":"云服务器基本配置","slug":"云服务器基本配置","date":"2017-07-25T13:39:02.000Z","updated":"2017-08-13T03:12:50.256Z","comments":true,"path":"2017/07/25/云服务器基本配置/","link":"","permalink":"http://yoursite.com/2017/07/25/云服务器基本配置/","excerpt":"","text":"添加管理用户12345adduser user_djgpasswd -a dj_user sudosudo visudo添加：dj_user ALL=(ALL:ALL) ALL保存：按ctrl+x,再按shift+y,然后enter 配置SSH无密码登录","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"}]},{"title":"sublime个人配置","slug":"sublime个人配置","date":"2017-07-03T13:49:36.000Z","updated":"2017-08-13T03:28:13.610Z","comments":true,"path":"2017/07/03/sublime个人配置/","link":"","permalink":"http://yoursite.com/2017/07/03/sublime个人配置/","excerpt":"一直以来非常喜爱sublime的轻便简洁，考虑到会更换电脑，重装系统等情况，在此将平时使用sublime安装的插件以及配置记录下来。 插件MarkdownEditing这是一款实时预览markdown格式文本的插件，打开MarkdownEditing配置文件 Markdown GFM Settings - user写入如下配置","text":"一直以来非常喜爱sublime的轻便简洁，考虑到会更换电脑，重装系统等情况，在此将平时使用sublime安装的插件以及配置记录下来。 插件MarkdownEditing这是一款实时预览markdown格式文本的插件，打开MarkdownEditing配置文件 Markdown GFM Settings - user写入如下配置12345&#123; \"color_scheme\": \"Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme\", //黑色主题 \"draw_centered\": false, //左边不空出来 \"wrap_width\": 90 //换行字数&#125; MarkdownPreview按CTRL + B生成网页HTML；在最前面添加[TOC]自动生成目录； OmniMarkupPreviwer实时在浏览器中预，而MarkdownPreview是需要手动生成的和F5的。览如果双屏的话，应该具有不错的体验。快捷键如下： Ctrl+Alt+O: Preview Markup in Browser. Ctrl+Alt+X: Export Markup as HTML. Ctrl+Alt+C: Copy Markup as HTML. TableEditorMarkdown中的表格书写体验真心不咋样，所有有人为这个开发了一个插件，具有较好的自适应性，会自动对齐，强迫症患者喜欢。首先需要用ctrl + shift + p打开这个功能（Table Editor: Enable for current syntax or Table Editor: Enable for current view or “Table Editor: Set table syntax … for current view”），然后就可以狂用tab来自动完成 Babel支持ES6、JSX语法高亮 Emmet解决Emmet在jsx语法下无法使用问题，Preferences-&gt;Key Bindings - User加上以下代码12345678910111213141516171819202122232425262728293031[&#123; \"keys\": [ \"tab\" ], \"args\": &#123; \"action\": \"expand_abbreviation\" &#125;, \"command\": \"run_emmet_action\", \"context\": [&#123; \"key\": \"emmet_action_enabled.expand_abbreviation\" &#125;]&#125;, &#123; \"keys\": [\"tab\"], \"command\": \"expand_abbreviation_by_tab\", \"context\": [&#123; \"operand\": \"source.js\", \"operator\": \"equal\", \"match_all\": true, \"key\": \"selector\" &#125;, &#123; \"key\": \"preceding_text\", \"operator\": \"regex_contains\", \"operand\": \"(\\\\b(a\\\\b|div|span|p\\\\b|button)(\\\\.\\\\w*|&gt;\\\\w*)?([^&#125;]*?&#125;$)?)\", \"match_all\": true &#125;, &#123; \"key\": \"selection_empty\", \"operator\": \"equal\", \"operand\": true, \"match_all\": true &#125;]&#125;] Color Highlighter安装 Color Highlighter，会自动高亮代码中的颜色，在写纯css的时候比较有用。 JsFormatJS格式化 Alignment等号对齐（Ctrl+Alt+A） CSScombCSS属性排序 配置高分屏文件名显示乱码问题preferences settings-user添加下面两项配置12\"dpi_scale\": 1.0,\"font_size\": 16 配置node.js编译环境cmd + b 是编译，比如我添加了直接调用 node.js ，这样测试一些函数最方便了，不用打开浏览器。tools -&gt; Build System -&gt; new Build System -&gt; 保存为 node.sublime-build：1234&#123; \"cmd\": [\"/usr/local/bin/node\", \"$file\"], \"selector\": \"source.js\"&#125;","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"http://yoursite.com/tags/sublime/"}]},{"title":"服务器配置安装MongoDB","slug":"服务器配置安装MongoDB","date":"2017-07-03T13:31:41.000Z","updated":"2017-07-24T13:52:54.666Z","comments":true,"path":"2017/07/03/服务器配置安装MongoDB/","link":"","permalink":"http://yoursite.com/2017/07/03/服务器配置安装MongoDB/","excerpt":"文档 https://docs.mongodb.com/v3.0/tutorial/install-mongodb-on-ubuntu/ 下载太慢解决sudo vi /etc/apt/sources/list.d/mongodb-org-3.0.list修改http://mirrors.aliyun.com/mongodb/apt/ubuntu trusty/mongodb-org/3.0 multiverse","text":"文档 https://docs.mongodb.com/v3.0/tutorial/install-mongodb-on-ubuntu/ 下载太慢解决sudo vi /etc/apt/sources/list.d/mongodb-org-3.0.list修改http://mirrors.aliyun.com/mongodb/apt/ubuntu trusty/mongodb-org/3.0 multiverse 防火墙开放27017端口sudo vi /etc/iptables.up.rules 添加 123# mongodb connect-A INPUT -s 127.0.0.1 -p tcp --destination-port 27017 -m state --state NEW,ESTABLISHED -j ACCEPT-A OUTPUT -d 127.0.0.1 -p tcp --source-port 27017 -m state --state ESTABLISHED -j ACCEPT 重载防火墙sudo iptables-restore &lt; /etc/iptables.up.rules 启动数据库&amp;停止数据库启动 mongo停止服务 sudo service mongod stop启动服务 sudo service mongod start修改数据库默认端口27017sudo vi /etc/mongod.conf修改 port: 27017 ==&gt; port: 19999修改防火墙相应配置启动防火墙 mongo --port 19999本地数据上传服务器(windows)备份 mongodump -h 127.0.0.1:27017 -d databaseName -o folderName打包 tar zcvf dumall.tar.gz dumall-reback上传 scp dumall.tar.gz dj_user@101.201.70.122:/home/dj_user/dbbackup/导入数据库到服务器数据库解压 tar xvf dumall.tar.gz导入 mongorestore --host 127.0.0.1:27017 -d dumall ./dbbackup/dumall-reback/dumall/导入单表到服务器数据库本地保存 mongoexport -d dumall -c goods -o ./dumall-goods.json本地上传 scp ./dumall-goods.json dj_user@101.201.70.122:/home/dj_user/dbbackup/服务器导入 mongoimport --host 127.0.0.1:27017 -d dumall -c goods ./dbbackup/dumall-goods.json删除数据库mongo --host 127.0.0.1:27017 dumall --eval &quot;db.dropDatabase()&quot;","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"获取隐藏元素的高度","slug":"获取隐藏元素的高度","date":"2017-04-30T14:11:04.000Z","updated":"2017-07-02T04:52:19.151Z","comments":true,"path":"2017/04/30/获取隐藏元素的高度/","link":"","permalink":"http://yoursite.com/2017/04/30/获取隐藏元素的高度/","excerpt":"1.隐藏元素的方式“隐藏”元素的方式有很多种：display:none,visibility:hiden,opacity:0,height:0; overflow:hidden,transform:scale(0) “隐藏”的区别visibility:hidden和opacity:0元素在文档流中占据位置，这些元素有高度且可以获取","text":"1.隐藏元素的方式“隐藏”元素的方式有很多种：display:none,visibility:hiden,opacity:0,height:0; overflow:hidden,transform:scale(0) “隐藏”的区别visibility:hidden和opacity:0元素在文档流中占据位置，这些元素有高度且可以获取 如何获取隐藏元素的高度(scrollHeiht)这里所说的隐藏元素是指类似display:none的隐藏 设置 height:0; overflow:hidden,此时元素达到隐藏的效果，clientHight、offsetHeight为0,但scrollHeight是有值的。1.scrollHeight是一个元素没有滚动条时的高度2.当一个元素没有滚动条时scrollHeight === offsetHeight 关于重绘和重排：https://xdlrt.github.io/2016/11/05/2016-11-05/","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS中居中的几种方法","slug":"CSS中居中的几种方法","date":"2017-02-26T10:19:22.000Z","updated":"2017-08-13T08:30:57.931Z","comments":true,"path":"2017/02/26/CSS中居中的几种方法/","link":"","permalink":"http://yoursite.com/2017/02/26/CSS中居中的几种方法/","excerpt":"本文主要总结一下平常所能用到的各种使用CSS居中的方法。 水平居中宽度未知margin: auto 0水平居中平常比较常用的方法，前提是不受float影响","text":"本文主要总结一下平常所能用到的各种使用CSS居中的方法。 水平居中宽度未知margin: auto 0水平居中平常比较常用的方法，前提是不受float影响123456789101112131415*&#123; padding: 0; margin: 0;&#125;.box&#123; width: 300px; height: 300px; border: 3px solid red;&#125;img&#123; display: block; width: 100px; height: 100px; margin: 0 auto;&#125; text-align：center水平居中img的display：inline-block；类似一样在不受float影响下进行实在父元素上添加效果让它进行水平居中 123456789101112131415*&#123; padding: 0; margin: 0;&#125;.box&#123; width: 300px; height: 300px; border: 3px solid red; text-align: center;&#125;img&#123; display: inline-block; width: 100px; height: 100px;&#125; 水平垂直居中宽高已知绝对定位和margin设为负值这种方法的局限性在于需要知道需要垂直居中的宽高才能实现，经常使用这种方法1234567891011121314151617181920*&#123; padding: 0; margin: 0;&#125;.box&#123; width: 300px; height: 300px; background:#e9dfc7; border:1px solid red; position: relative;&#125;img&#123; width: 100px; height: 150px; position: absolute; top: 50%; left: 50%; margin-top: -75px; margin-left: -50px;&#125; 宽高未知绝对定位和margin:auto123456789101112131415161718192021*&#123; padding: 0; margin: 0;&#125;.box&#123; width: 300px; height: 300px; background:#e9dfc7; border:1px solid red; position: relative;&#125;img&#123; width: 100px; height: 100px; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;&#125; 绝对定位和transfrom1234567891011121314151617181920*&#123; padding: 0; margin: 0;&#125;.box&#123; width: 300px; height: 300px; background:#e9dfc7; border:1px solid red; position: relative;&#125;img&#123; width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; diplay：table-cell水平垂直居中其实这个就是把其变成表格样式，再利用表格的样式来进行居中 12345678910111213.box&#123; width: 300px; height: 300px; background:#e9dfc7; border:1px solid red; display: table-cell; vertical-align: middle; text-align: center;&#125;img&#123; width: 100px; height: 150px;&#125; flexBox水平垂直居中(兼容IE11以上)这个是CSS3的新特性 12345678910111213.box&#123; width: 300px; height: 300px; background:#e9dfc7; border:1px solid red; display: flex; justify-content: center; align-items:center;&#125;img&#123; width: 150px; height: 100px;&#125;","categories":[],"tags":[{"name":"CSS布局","slug":"CSS布局","permalink":"http://yoursite.com/tags/CSS布局/"}]},{"title":"Node.js+express构建电影网站","slug":"Node-js-express构建电影网站","date":"2017-02-21T10:46:02.000Z","updated":"2017-07-02T02:35:00.761Z","comments":true,"path":"2017/02/21/Node-js-express构建电影网站/","link":"","permalink":"http://yoursite.com/2017/02/21/Node-js-express构建电影网站/","excerpt":"本项目是一个简单的电影网站，实现了用户注册、登录、登出，电影的录入、移除、查看、修改等后台管管理功能。用户可以对电影进行评论，用户之间也可以相互评论。为了方便电影的录入，利用豆瓣Api，使用jsonp跨域请求，实现豆瓣电影数据同步。项目后端使用Node.js+express+MongoDB数据库构建，前端是使用jade模版引擎，样式使用了Bootstrap框架，以及jQuery工具库。","text":"本项目是一个简单的电影网站，实现了用户注册、登录、登出，电影的录入、移除、查看、修改等后台管管理功能。用户可以对电影进行评论，用户之间也可以相互评论。为了方便电影的录入，利用豆瓣Api，使用jsonp跨域请求，实现豆瓣电影数据同步。项目后端使用Node.js+express+MongoDB数据库构建，前端是使用jade模版引擎，样式使用了Bootstrap框架，以及jQuery工具库。 运行项目 git clone https://github.com/dj940212/showMovie.git grunt 1.grunt集成自动化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105module.exports = function(grunt)&#123; grunt.initConfig(&#123; watch:&#123; jade:&#123; files:['views/**'], options:&#123; livereload:true &#125; &#125;, js:&#123; files:['public/js/**','models/**/*.js','schemas/**/*.js'], //tasks:['jshint'], options:&#123; livereload:true //重启服务 &#125; &#125;, &#125;, module.exports = function(grunt)&#123; grunt.initConfig(&#123; watch:&#123; jade:&#123; files:['views/**'], options:&#123; livereload:true &#125; &#125;, js:&#123; files:['public/js/**','models/**/*.js','schemas/**/*.js'], //tasks:['jshint'], options:&#123; livereload:true //重启服务 &#125; &#125;, &#125;, nodemon:&#123; dev:&#123; options:&#123; file:'app.js', args:[], ignoredFiles:['README.md','node_modules/**','.DS_Store'], watchedExtensions:['js'], watchedFolders:['./'], debug:true, delayTime:1, env:&#123; PORT:3000 &#125;, cwd:__dirname &#125; &#125; &#125;, concurrent:&#123; tasks:['nodemon','watch'], options:&#123; logConcurrentOutput:true &#125; &#125; &#125;) grunt.loadNpmTasks('grunt-contrib-watch') //监听文件变更，注册其他任务启动 grunt.loadNpmTasks('grunt-nodemon') //监听文件变更，重启服务 grunt.loadNpmTasks('grunt-concurrent') //并发执行任务 grunt.option('force',true) //避免打断，强制执行 grunt.registerTask('default',['concurrent'])&#125;:&#123; dev:&#123; options:&#123; file:'app.js', args:[], ignoredFiles:['README.md','node_modules/**','.DS_Store'], watchedExtensions:['js'], watchedFolders:['./'], debug:true, delayTime:1, env:&#123; PORT:3000 &#125;, cwd:__dirname &#125; &#125; &#125;, concurrent:&#123; tasks:['nodemon','watch'], options:&#123; logConcurrentOutput:true &#125; &#125; &#125;) grunt.loadNpmTasks('grunt-contrib-watch') //监听文件变更，注册其他任务启动 grunt.loadNpmTasks('grunt-nodemon') //监听文件变更，重启服务 grunt.loadNpmTasks('grunt-concurrent') //并发执行任务 grunt.option('force',true) //避免打断，强制执行 grunt.registerTask('default',['concurrent'])&#125; 1.文件目录 入口文件index.js -&gt; 主程序入口启动Express程序，启动并连接数据库，路由分发，引入配置 路由routes.js -&gt; 路由文件 1234567891011121314151617181920212223242526272829303132333435363738394041 module.exports = function(app)&#123; app.use(function(req,res,next)&#123; var _user = req.session.user; app.locals.user = _user; next() &#125;) // Index app.get('/', Index.index); //User app.post('/user/signup', User.signup) app.post('/user/signin', User.signin) app.get('/signin',User.showSignin) app.get('/signup',User.showSignup) app.get('/logout',User.logout) app.get('/admin/userlist',User.signinRequired,User.adminRequired,User.userlist); //Movie //详情页 app.get('/movie/:id', Movie.detail); //列表页 app.get('/admin/list',User.signinRequired,User.adminRequired, Movie.list); // 后台录入页 app.get('/admin/movie',User.signinRequired,User.adminRequired, Movie.new); // 逻辑控制:更新 app.get('/admin/update/:id',User.signinRequired,User.adminRequired, Movie.update); // 逻辑控制:插入 app.post('/admin/movie/new',User.signinRequired,User.adminRequired, Movie.save); // 逻辑控制:删除 app.delete('/admin/delete',User.signinRequired,User.adminRequired, Movie.del); //评论 app.post('/user/comment',User.signinRequired,Comment.save) //分类 app.get('/admin/category/new',User.signinRequired,User.adminRequired, Category.new); app.post('/admin/category',User.signinRequired,User.adminRequired, Category.save); app.get('/admin/category/list',User.signinRequired,User.adminRequired, Category.list);&#125; 视图文件 layout.hade -&gt; 布局文件 2.数据库模式模型设计创建category、comment、movie、user四个数据库模型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 //电影分类 var CategorySchema = new Schema(&#123; name: String, movies: [&#123;type: ObjectId, ref: 'Movie'&#125;], meta: &#123; createAt: &#123; type: Date, default: Date.now() &#125;, updateAt: &#123; type: Date, default: Date.now() &#125; &#125; &#125;) //用户评论 var CommentSchema = new mongoose.Schema(&#123; movie:&#123;type:ObjectId, ref:'Movie' &#125;, from:&#123;type:ObjectId, ref:'User' &#125;, reply:[&#123; from:&#123;type:ObjectId,ref:'User'&#125;, to:&#123;type:ObjectId,ref:'User'&#125;, content:String &#125;], to:&#123;type:ObjectId, ref:'User' &#125;, content:String, meta: &#123; createAt: &#123; type: Date, default: Date.now() &#125;, updateAt: &#123; type: Date, default: Date.now() &#125; &#125; &#125;); //用户信息 var UserSchema = new mongoose.Schema(&#123; name:&#123; unique:true, type:String &#125;, password:String, role:&#123; type:Number, default:0 &#125;, meta: &#123; createAt: &#123; type: Date, default: Date.now() &#125;, updateAt: &#123; type: Date, default: Date.now() &#125; &#125; &#125;); //电影 var MovieSchema = new Schema(&#123; doctor: String, title: String, language: String, country: String, year: Number, summary: String, poster: String, category:&#123; type:ObjectId, ref:'Category' &#125;, meta: &#123; createAt: &#123; type: Date, default: Date.now() &#125;, updateAt: &#123; type: Date, default: Date.now() &#125; &#125;&#125;); 3. 数据库交互 建立数据库链接 123456// movie为mongodb的一个数据库var dbUrl = 'mongodb://localhost/movie';var db = mongoose.connect(dbUrl)db.connection.on('open',function()&#123; console.log(\"----数据库连接成功！------\");&#125;); 数据库交互 12345678910111213141516171819202122MovieSchema.pre('save', function (next) &#123; if (this.isNew) &#123; this.meta.createAt = this.meta.updateAt = Date.now(); &#125; else &#123; this.meta.updateAt = Date.now(); &#125; next();&#125;);MovieSchema.statics = &#123; fetch: function (cb) &#123; return this .find(&#123;&#125;) .sort('meta.updateAt') .exec(cb); &#125;, findById: function (id, cb) &#123; return this .findOne(&#123;_id: id&#125;) .exec(cb); &#125;&#125;; 4.用户登录注册后台存储使用bcrypt-nodejs模块，实现对密码的加盐，转换hash值，以及登录是密码的比对 123456789101112131415161718192021222324252627282930313233343536//实例方法UserSchema.methods = &#123; comparePassword:function(_password,cb)&#123; bcrypt.compare(_password,this.password,function(err,isMatch)&#123; if (err) &#123; return cb(err) &#125; cb(null,isMatch) &#125;) &#125;&#125;UserSchema.pre('save', function (next) &#123; var user = this if (this.isNew) &#123; this.meta.createAt = this.meta.updateAt = Date.now(); &#125; else &#123; this.meta.updateAt = Date.now(); &#125; //随机salt及密码加密 bcrypt.genSalt(SALT_WORK_FACTOR, function(err, salt)&#123; if (err) return next(err); bcrypt.hash(user.password, salt, null, function(err, hash) &#123; if (err) return next(err); user.password = hash; next(); &#125;); &#125;);&#125;); 5.用户权限管理UserSchema模式下增加一个role:Number用来区分用户的权限 0: nomal user1:verified user2:professonal user lg10:adminlg50:super admin 12345678910111213141516171819202122232425262728//用户中间件exports.signinRequired = function (req, res,next) &#123; var user = req.session.user console.log('当前用户') console.log(user) if (!user) &#123; return res.redirect('/signin') &#125; next(); &#125;;//管理员中间件exports.adminRequired = function (req, res,next) &#123; var user = req.session.user console.log(user) if (user.role &lt;= 10) &#123; return res.redirect('/signin') &#125; next() &#125;; 6.用户评论","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"雅虎军规","slug":"雅虎军规","date":"2017-02-17T05:40:46.000Z","updated":"2017-08-17T13:08:26.118Z","comments":true,"path":"2017/02/17/雅虎军规/","link":"","permalink":"http://yoursite.com/2017/02/17/雅虎军规/","excerpt":"当我们打开一个网页时，事实上，只有10%-20%的最终用户响应时间是花在从web服务器获取HTML文档并传送到浏览器的，至少80%的最终用户响应时间是花在了页面中的组件上（图片、脚本、样式表、Flash等）、太慢的网站经常会造成访客不再回返，因此，把精力放在这80%的时间可以极大的改善web的性能。而请求组件需要伴随着HTTP请求，而减少HTTP请求、减小HTTP请求大小等都是改善web性能的最佳实践","text":"当我们打开一个网页时，事实上，只有10%-20%的最终用户响应时间是花在从web服务器获取HTML文档并传送到浏览器的，至少80%的最终用户响应时间是花在了页面中的组件上（图片、脚本、样式表、Flash等）、太慢的网站经常会造成访客不再回返，因此，把精力放在这80%的时间可以极大的改善web的性能。而请求组件需要伴随着HTTP请求，而减少HTTP请求、减小HTTP请求大小等都是改善web性能的最佳实践 规则1：减少HTTP请求改善响应时间的最简单途径就是减少组件(图片，脚本，样式表、Flash等）的数量，并由此减少http请求的数量（1）CSS Sprites（2）合并脚本和样式表 规则2：使用内容发布网络通常来说，Web客户端离当前Web服务器越近，响应时间会更快（1）内容发布网络（2）一些大型公司都拥有他们自己的CDN，但使用一个CDN服务提供商更为有效 规则3：添加Expires头（1）主要通过配置组件，使用一个长久的Expires头，使这些组件能够被缓存，使在后续的页面浏览中避免不必要的http请求（浏览器可以直接从硬盘上读取组件而无需生成任何http流量）,web服务器使用Expires头来告诉web客户端它可以使用一个组件的当前副本，直到指定的时间为止（2）长久的Expires头最常用于图片，但应该将其应用在所有组件上，包括脚本、样式表和Flash等不经常变化的组件，但添加长久的Expires会带来额外的开发成本（3）浏览器（和代理）通过使用缓存来减少http请求的数量，并减小http响应的大小，从而使页面加载得更快，Expires在http响应中发送，web服务器通过使用Expires头来告诉Web客户端它可以使用一个组件的当前副本 （4）Expires头的限制：Expires头使用一个特定的时间，它要求服务器和客户端的时钟严格同步，另外，如果到了过期时间，需要在服务器配置中提供一个新的日期（5）Cache-Control头：http1.1引入的，主要用来克服Expires的限制主要使用max-age指令指定组件被缓存多久 注：可以同时指定Expires和Cache-Control两个响应头，因为有些浏览器不支持http1.1（6）修订文件名：为了确保用户能够获取组件的最新版本，需要在所有HTML页面中修改组件的文件名（7）一个具有长久的Expires头的组件将会被缓存，在后续请求时浏览器直接从磁盘上读取它，避免了一个http请求 如果一个组件没有长久的Expires头，它仍然会存储在浏览器的缓存中，在后续请求中，浏览器会检查缓存并发现组件以及过期。为了提高效率，浏览器会向原始服务器发送一个条件GET请求，如果组件没有改变，原始服务器可以免于发送整个组件，而是发送一个很小的头，告诉浏览器可以使用其缓存的组件 规则4：压缩组件（使用gzip编码压缩http响应包）（1）主要通过http响应的大小来减少响应时间，从http1.1开始，Web客户端可以通过http请求中的Accept-Encoding来标识对压缩的支持 如果Web服务器看到请求中有这个头，就会使用客户端列出来的方法中的一种来压缩响应，Web服务器通过响应中的Content-Encoding头来通知Web客户端 （2）压缩什么：一般压缩HTML文档、样式表和脚本（3）压缩的成本：服务器端会花费额外的CPU周期来完成压缩，客户端要对压缩文件进行解压缩 规则5：将样式表放在顶部（1）将样式表放在底部，可能会延迟页面的加载，会出现“白屏”和“无样式闪烁”，将样式表放在顶部，可以使页面逐步呈现，避免页面出现”白屏“和“无样式闪烁”（2）白屏：浏览器延迟内容呈现，直到所有的样式表都下载完毕后才开始开始显示内容，即页面完全空白，直到页面所有内容同时涌上屏幕 无样式闪烁：样式表被正确地下载及解析，已经呈现的页面和图片要用新的样式重绘（3）link和@import： 注：使用@import规则可能会导致白屏现象，即使是放在中 一般组件都是按照它们在页面中出现的顺序下载的，而使用@import会带来下载时的无序性 规则6：将脚本放在底部（1）将脚本放在底部，既可以使页面逐步呈现，也可以提高下载的并行度（2）将样式表放在中，可以首先下载它们而不会阻止页面呈现，使用脚本时，对于所有位于脚本以下的内容，逐步呈现都被阻塞了。将脚本放在页面越靠下的地方，意味着越多的内容能够逐步地呈现（3）http1.1建议浏览器从每个主机名并行地下载两个组件。然而，在下载脚本时并行下载其实是被禁用的，即使是用了不同的主机名，浏览器也不会启动其他的下载（4）脚本对web页面的影响：脚本会阻塞其后面内容的呈现，脚本会阻塞其后面组件的下载（脚本会阻塞并行下载） 规则7：避免CSS表达式（1）CSS表达式不只在页面呈现和大小改变时求值，当页面滚动，甚至连用户鼠标的页面移动时都要求值 规则8：使用外部的JavaScript和CSS（1）在某种程度上，内联会快一些，尽管总下载量时是相同的，但外部示例需要承担多个http请求带来的开销。但是现实中还是使用外部文件会产生比较快的页面，因为javascript和css文件有可能被浏览器缓存起来（2）使用外部文件可以提高组件的重用率 规则9：减少DNS查找（1）Internet是通过IP地址来查找服务器的，由于IP地址很难记忆，通常使用包含主机名的URL来代替它，但当浏览器发送其请求时，IP地址仍然是必需的，这就是Domain Name System(DNS)所处的角色。DNS将主机名映射到IP地址上，在输入一个URL时，连接到浏览器的DNS解析器会返回服务器的IP地址（2）DNS也是开销，在DNS查找完成之前，浏览器不能从主机名那里下载到任何东西，响应时间依赖于DNS解析器（通常由你的ISP提供）（3）DNS缓存：DNS查找可以被缓存起来以提高性能，在用户请求了一个主机名后，DNS信息会留在操作系统的DNS缓存中，之后对于该主机名的请求将无需进行过多的DNS查找（4）通过使用keep-Alive和较少的域名来减少DNS查找，keep-Alive通过重用现有连接避免了重复的DNS查找，减少唯一主机名的数量可以减少DNS查找（5）建议：可以将组件分别放在至少2个，但不要超过4个主机名下，这是在减少DNS查找和允许高度并行下载之间作出的很好的权衡 规则10：精简Javascript（1）精简是从代码中移除不必要的字符以减小其大小进而改善加载时间，在代码被精简后，所有的注释以及不必要的空白字符都将被移除（2）内联的javascript也应该被精简（3）精简CSS能够带来的节省通常要小于精简javascript，因为css中的注释和空白比javascript中的少，最大的潜在节省来自于优化CSS——合并相同的类，移除不适用的类等 规则11：避免重定向（1）重定向就是，在网页上设置一个约束条件，条件满足，就自动转入到其它网页、网址（2）重定向用于将用户从一个url重新路由到另一个url，重定向有很多种——301和302是最常用的两种，重定向会使你的页面变慢，javascript可以通过document.location设置为期望的URL执行重定向（3）当web服务器向浏览器返回一个重定向时，响应中就会返回一个范围在3xx的状态码，这表示用户代理必需执行进一步操作才能完成请求注：304并不是真的重定向，它用来响应条件GET请求，避免下载已经存在于浏览器缓存中的数据（4）重定向是如何损伤性能的：重定向会延迟整个HTML文档的传输，在HTML文档到达之前，页面中不会呈现出任何东西，也没有任何组件会被下载 规则12：移除重复脚本（1）重复脚本损伤性能的方式有两种——不必要的HTTP请求和执行javascript所浪费的时间（2）在页面中多次包含相同的脚本会使页面变慢 在IE中，如果脚本没有被缓存，或在重新加载页面时，会产生额外的http请求 在火狐和IE中，脚本会被多次求值 规则13：配置ETag（1）ETag（实体标签）是web服务器和浏览器用于确认缓存组件的一种机制（2）浏览器下载组件时，会将它们存储到缓存中，在后续的页面查看中，如果缓存的组件是“新鲜”的，浏览器就会从磁盘上读取它，避免产生http请求，如果缓存的组件过期了（或者用户明确地重新加载了页面），浏览器在重用它之前必须首先检查它是否仍然有效，这称为一个条件get请求，如果浏览器缓存中的组件是有效的（即它能够和原始服务器上的组件相匹配），原始服务器不会返回整个组件，而是返回一个304的状态码（3）服务器在检测缓存的组件是否和原始服务器上的组件匹配时有两种方式：比较最新修改日期，比较实体标签（ETag是唯一标识了一个组件的一个特定版本的字符串）（4）ETag带来的问题，当浏览器向一台服务器获取了原始组件，又向另一台不同的服务器发起条件get请求时，ETag是不会匹配的（5）即使组件具有长久的Expires头，一旦用户单击了Reload或Refresh按钮。依然会产生条件get请求 规则14：使Ajax可缓存","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"}]},{"title":"设备像素比devicePixelRatio","slug":"设备像素比devicePixelRatio","date":"2017-02-17T05:29:02.000Z","updated":"2017-07-02T02:56:18.735Z","comments":true,"path":"2017/02/17/设备像素比devicePixelRatio/","link":"","permalink":"http://yoursite.com/2017/02/17/设备像素比devicePixelRatio/","excerpt":"设备像素比的定义： window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。公式表示就是：window.devicePixelRatio = 物理像素 / dips","text":"设备像素比的定义： window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。公式表示就是：window.devicePixelRatio = 物理像素 / dips dip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备。 所有非视网膜屏幕的iphone在垂直的时候，宽度为320物理像素。当你使用的时候，会设置视窗布局宽度（不同于视觉区域宽度，不放大显示情况下，两者大小一致，见下图）为320px, 于是，页面很自然地覆盖在屏幕上。 这样，非视网膜屏幕的iphone上，屏幕物理像素320像素，独立像素也是320像素，因此，window.devicePixelRatio等于1. 而对于视网膜屏幕的iphone，如iphone4s, 纵向显示的时候，屏幕物理像素640像素。同样，当用户设置的时候，其视区宽度并不是640像素，而是320像素，这是为了有更好的阅读体验 – 更合适的文字大小。 这样，在视网膜屏幕的iphone上，屏幕物理像素640像素，独立像素还是320像素，因此，window.devicePixelRatio等于2.","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"vue.js仿饿了吗App","slug":"vue.js仿饿了吗App","date":"2017-02-16T11:29:03.000Z","updated":"2017-07-02T04:47:08.652Z","comments":true,"path":"2017/02/16/vue.js仿饿了吗App/","link":"","permalink":"http://yoursite.com/2017/02/16/vue.js仿饿了吗App/","excerpt":"本项目仿饿了吗App商家模块（包括商品、评论、商家介绍等各模块），使用Vue.js+es6+webpack等前端热门技术，采用组件化、模块化开发方式。使用flex布局，stylus css预处理器。使用vue-router插件实现路由，数据交互用vue-resource插件实现。","text":"本项目仿饿了吗App商家模块（包括商品、评论、商家介绍等各模块），使用Vue.js+es6+webpack等前端热门技术，采用组件化、模块化开发方式。使用flex布局，stylus css预处理器。使用vue-router插件实现路由，数据交互用vue-resource插件实现。项目运行：123456//克隆项目git clone https://github.com/dj940212/sell.git//安装依赖npm install//运行项目npm run dev 1.项目目录本项目使用webpack模版 2.项目组件结构下面为本项目的各组件结构（图为Chrome插件 Vue Devtools 截图） 3.mock数据本项目为纯前端项目，项目中数据均为模拟数据， 4.vue-routervue-router 12345678910111213141516171819202122Vue.use(VueRouter);let app = Vue.extend(App);let router = new VueRouter(&#123; linkActiveClass: 'active'&#125;);router.map(&#123; '/goods': &#123; component: goods &#125;, '/ratings': &#123; component: ratings &#125;, 'seller': &#123; component: seller &#125;&#125;);router.start(app, '#app');router.go('/goods'); 5.header组件","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"}]},{"title":"在GitHubPages上搭建项目主页","slug":"在GitHubPages上搭建项目主页","date":"2017-02-16T07:10:36.000Z","updated":"2017-02-16T11:29:42.000Z","comments":true,"path":"2017/02/16/在GitHubPages上搭建项目主页/","link":"","permalink":"http://yoursite.com/2017/02/16/在GitHubPages上搭建项目主页/","excerpt":"","text":"Github Pages是Github免费提供给开发者的一款托管个人网站的产品，这绝对是个好东西啊。目前来看只能托管静态内容，但是这已经足够我们用了。GitHub Pages主页 终端里切换到你的工作目录 创建一个新的gh-pages分支 git checkout --orphan gh-pages //新建一个gh-pages分支并且没有任何提交历史，不要–orphan也行 删除里面的内容（可选，如果里面是你要提交的内容就不用删）rm -rf * //删除当前目录全部内容（可选） git add和git commit之后就可以正常push了git push -u origin gh-pages","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"H5报告","slug":"H5报告","date":"2017-02-16T05:10:16.000Z","updated":"2017-07-02T02:32:54.336Z","comments":true,"path":"2017/02/16/H5报告/","link":"","permalink":"http://yoursite.com/2017/02/16/H5报告/","excerpt":"项目简介项目预览 本项目为一个H5报告页面，运用了HTML5、CSS3、JS等技术，采用组件式开发，页面滚动采用了基于jQuery的FullPage.js，运用Canvas制作了柱形图、折线图、饼图、散点图、雷达图等多种动态图表组件。","text":"项目简介项目预览 本项目为一个H5报告页面，运用了HTML5、CSS3、JS等技术，采用组件式开发，页面滚动采用了基于jQuery的FullPage.js，运用Canvas制作了柱形图、折线图、饼图、散点图、雷达图等多种动态图表组件。 项目结构 事件12345678910111213141516171819//page 上绑定进入和离开事件处理程序$('.page').on('onLeave',function()&#123; console.log( $(this).attr('id') ,'==&gt;&gt;' ,'onLeave' ); $(this).find('.component').trigger('onLeave');&#125;)$('.page').on('onLoad',function()&#123; console.log( $(this).attr('id') ,'==&gt;&gt;' ,'onLoad' ); $(this).find('.component').trigger('onLoad');&#125;)//component上绑定进入和离开事件处理程序$('.component').on('onLoad',function()&#123; $(this).fadeIn(); return false;&#125;)$('.component').on('onLeave',function()&#123; $(this).fadeOut(); return false;&#125;) 核心对象与方法H5为整个项目的内容组件对象，H5包含addPage（）、addComponent（）、loader（）三个方法。addComponent()方法接受两个参数，第一个参数为组件名name，第二个参数为一个对象cfg，储存组件基本参数。loader()方法,每个方法都返回this,使其能形成链式调用。123456789101112131415161718192021222324252627282930h5.addPage('face') .addComponent('logo',&#123; text:'logo', width:400, height:100, css:&#123;backgroundColor:'red',top:200,opacity:0&#125;, center:true, animateIn:&#123;opacity:1&#125;, animateOut:&#123;opacity:0&#125; &#125;) .addComponent('slogan',&#123; text:'slogan', width:400, height:100, css:&#123;backgroundColor:'red',top:350&#125;, center:true, &#125;).addPage('desc') .addComponent('caption',&#123; text:'核心理念', width:400, height:100, css:&#123;backgroundColor:'green',top:350&#125;, center:true, &#125;).addPage('page-3') .addComponent('caption',&#123;text:'课程方向分布'&#125;).loader( ); loader( )方法123456789101112131415this.loader = function( firstPage )&#123; this.el.fullpage(&#123; onLeave:function( index, nextIndex, direction) &#123; $(this).find('.h5_component').trigger('onLeave'); &#125;, afterLoad:function( anchorLink, index ) &#123; $(this).find('.h5_component').trigger('onLoad'); &#125; &#125;); this.page[0].find('.h5_component').trigger('onLoad'); this.el.show(); if(firstPage)&#123; $.fn.fullpage.moveTo( firstPage ); &#125; &#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"项目介绍","slug":"项目介绍","permalink":"http://yoursite.com/tags/项目介绍/"}]},{"title":"ES6学习笔记","slug":"ES6学习笔记","date":"2016-12-23T11:48:25.000Z","updated":"2017-07-02T02:32:35.412Z","comments":true,"path":"2016/12/23/ES6学习笔记/","link":"","permalink":"http://yoursite.com/2016/12/23/ES6学习笔记/","excerpt":"let命令 let用法类似于var,但是所声明的变量只在let所在的代码块内有效1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b //","text":"let命令 let用法类似于var,但是所声明的变量只在let所在的代码块内有效1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 不存在变量提升 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 只要块级作用域内存在let命令，形成暂时性死区 不允许重复声明 const命令const声明一个只读的常量。一旦声明，常量的值就不能改变。const的作用域与let命令相同：只在声明所在的块级作用域内有效。 变量的解构赋值(数组，对象，字符串，数值和布尔值，函数参数）ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 以前，为变量赋值，只能直接指定值。 123let a = 1;let b = 2;let c = 3; ES6允许写成下面这样。let [a, b, c] = [1, 2, 3]; 下面是使用嵌套数组进行解构的例子，如果解构不成功，变量的值就等于undefined。 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [\"foo\", \"bar\", \"baz\"];third // \"baz\"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // [] 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 默认值，解构赋值允许指定默认值。 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 模版字符串传统的JavaScript语言，输出模板通常是这样写的。 123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。 12345$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。 模板字符串之中还能调用函数。 箭头函数ES6允许使用“箭头”（=&gt;）定义函数。 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789101112131415var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;;//返回一条语句var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;//返回一个对象var getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); Promise 对像Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用 stream 模式是比部署Promise更好的选择。 ……. ClassJavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。 12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。 1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6的类，完全可以看作构造函数的另一种写法。 123456class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // true","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Vue.js学习笔记","slug":"Vue-js学习笔记","date":"2016-12-21T05:49:24.000Z","updated":"2017-02-28T07:43:02.000Z","comments":true,"path":"2016/12/21/Vue-js学习笔记/","link":"","permalink":"http://yoursite.com/2016/12/21/Vue-js学习笔记/","excerpt":"","text":"自定义按键修饰符别名12//将键码为17的Ctrl健定义别名为ctrlVue.directive('on').keyCodes.ctrl=17; vue-resource get 12345678910111213141516//获取一个普通的文本数据this.$http.get('a.txt').then(function(res)&#123; alert(res.status)&#125;,function()&#123; alert(\"出错\")&#125;);//给服务发送数据:√this.$http.get('get.php',&#123; a:1, b:2&#125;).then(function(res)&#123; alert(res.data);&#125;,function(res)&#123; alert(res.status);&#125;); post 1234567this.$http.post('post.php',&#123;a:1,b:2&#125;,&#123; emulateJSON:true //发送json数据&#125;).then(function(res)&#123; alert(res.status)&#125;,function()&#123; alert(\"出错\")&#125;); jsonp好搜接口：https://sug.so.360.cn/suggest?callback=suggest_so&amp;word=a 123456this.$http.jsonp('https://sug.so.360.cn/suggest',&#123;word:'a'&#125;).then(function(res)&#123; alert(res.data.s)&#125;,function()&#123; alert(\"出错\")&#125;); 百度接口：https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=a&amp;cb=show 123456789this.$http.jsonp('https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su', &#123;wd:'a'&#125;, &#123;jsonp:'cb'&#125; //callback的名字，默认名字为\"callback\" ).then(function(res)&#123; alert(res.data.s) &#125;,function()&#123; alert(\"出错\") &#125;);&#125; vue-router版本 0.7.13 1234567891011121314151617181920212223242526//1.准备一个根组件 var App = Vue.extend(); //2.Home News组件都准备 var Home = Vue.extend(&#123; template:'&lt;h3&gt;我是主页&lt;/h3&gt;' &#125;); var News = Vue.extend(&#123; template:'&lt;h3&gt;卧室新闻&lt;/h3&gt;' &#125;); //3.准备路由 var router = new VueRouter(); //4.关联 router.map(&#123; 'home':&#123; component:Home &#125;, 'news':&#123; component:News &#125; &#125;); //5.跳转 router.redirect(&#123; '/':'home' &#125;); //6.启动路由 router.start(App,\"#box\"); 12345678910111213141516171819202122router.map(&#123; 'home':&#123; component:Home, //嵌套 subRoutes:&#123; 'login':&#123; component:&#123; template:'&lt;strong&gt;我是登录信息&lt;/strong&gt;' &#125; &#125;, 'reg':&#123; component:&#123; template:'&lt;strong&gt;我是注册信息&lt;/strong&gt;' &#125; &#125; &#125; &#125;, 'news':&#123; component:News, &#125;&#125;); 12345678910&lt;template id=\"detail\"&gt; &#123;&#123;$route.params | json&#125;&#125; &lt;!-- 获取id --&gt; &lt;br&gt; &#123;&#123;$route.path&#125;&#125; &lt;!-- 获取路径 --&gt; &lt;br&gt; &#123;&#123;$route.query | json&#125;&#125; &lt;!--传入数据 测试：url后传入\"?a=1&amp;b=2\" --&gt;&lt;/template&gt; vue生存周期钩子函数： created -&gt; 实例创建的时候执行beforeCompile -&gt; 编译之前执行compiled -&gt; 编译之后执行ready -&gt; 文本节点插入到文档中了 vm.$destroy() //销毁vue实例对象beforeDestroy -&gt; 销毁之前destroyed -&gt; 销毁之后 防止数据闪烁指令： v-cloak指令： v-text指令： v-html 计算属性默认形式 12345computed: &#123; now: function () &#123; return Date.now() &#125;&#125; 完整形式 123456789101112131415161718data:&#123; a:1&#125;,computed: &#123; b:&#123; get:function()&#123; //获取值 return this.a + 1 &#125;, set:function()&#123; //设置值 this.a = val; &#125; &#125;&#125;----------------------------------document.onclick = function()&#123; vm.b=10;&#125; vue实例方法 vm.$el -&gt; 元素 vm.$data -&gt; data vm.$mount -&gt; 手动挂载vue程序 vm.$options -&gt; 获取自定义属性 vm.destroy -&gt; 销毁对象 vm.$log() -&gt; 查看现在数据的状态 循环重复数据track-by = “$index” 过滤器 常用过滤器capitalize uppercase currencydebounce -&gt; 延迟执行，空一个输入参数延迟毫秒limitBy -&gt; 限制数据个数filterBy -&gt; 过滤数据oderBy -&gt; 排序 自定义过滤器 12345Vue.filter('todou',function(input)&#123; return input &lt; 10 ? '0' + input: ''+input;&#125;)9 | toDou // 09 格式化时间 12345Vue.filter('date',function(input)&#123; var date = new Date(input); return date.getFullYear()+'-'+(date.getMonth()+1)+'-'+date.getDate()+'' +date.getHours()+':'+date.getMinutes()+':'+date.getSecond();&#125;) 自定义指令Vue.drective(‘red’,function(){ this.el.style.background=’red’;}) 监听数据变化vm.$watch(name,function(){}) //浅度监视 vm.$watch(name,function(){},{deep:true}) //深度监视 父子组件数据传递 子组建获取父组件数据 12345//在调用子组件中&lt;bbb :m = \"数据\"&gt;&lt;/bbb&gt;子组件之内：props:['m','myMsg'] 父组件获得子组件数据子组件把数据发送到父组件vm.$emit(事件名称，数据) 父组件接收 v-on:事件名称=”” slot作用：占个位置","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"}]},{"title":"CSS清除浮动","slug":"CSS清除浮动","date":"2016-12-15T05:43:31.000Z","updated":"2017-08-13T08:30:21.948Z","comments":true,"path":"2016/12/15/CSS清除浮动/","link":"","permalink":"http://yoursite.com/2016/12/15/CSS清除浮动/","excerpt":"浮动属性会使当前标签脱离文档流，同时会影响父标签（高度塌陷）以及前后标签的布局，下面总结平时常用的清除浮动的方法。 浮动标签结尾处添加一个空标签&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;; 优点：简单易懂，浏览器支持好，不容易出问题缺点：增加很多空标签不易维护和理解","text":"浮动属性会使当前标签脱离文档流，同时会影响父标签（高度塌陷）以及前后标签的布局，下面总结平时常用的清除浮动的方法。 浮动标签结尾处添加一个空标签&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;; 优点：简单易懂，浏览器支持好，不容易出问题缺点：增加很多空标签不易维护和理解 给父级标签添加overflow:hidden 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度优点：简单、代码少、浏览器支持好缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 父级div定义 overflow:auto 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度优点：简单、代码少、浏览器支持好缺点：内部宽高超过父级div时，会出现滚动条。 父级标签也一起浮动 原理：所有代码一起浮动，就变成了一个整体缺点：会产生新的浮动问题,不推荐使用 父级标签定义display:table 原理：将div属性变成表格缺点：会产生新的未知问题,不推荐使用 利用伪类 目前比较通用的方法，推荐使用 123456789/*清除浮动，防止高度塌陷*/.clearfix:before,.clearfix:after&#123; content: \"\"; display: table;&#125;.clearfix:after&#123; clear: both;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"CSS页面布局","slug":"CSS页面布局","permalink":"http://yoursite.com/tags/CSS页面布局/"}]},{"title":"windows中路径太长文件无法删除","slug":"windows中路径太长文件无法删除","date":"2016-12-14T14:29:24.000Z","updated":"2016-12-14T14:41:22.000Z","comments":true,"path":"2016/12/14/windows中路径太长文件无法删除/","link":"","permalink":"http://yoursite.com/2016/12/14/windows中路径太长文件无法删除/","excerpt":"最近学习node.js，经常会遇到node_modules目录嵌套太深，无法删除的问题,后来在网上查了很长时间，终于解决了。 解决方法1.在要删除的文件夹目录下新建空白文件夹，如D:\\study\\empty;2.管理员方式打开命令行3.输入robocopy D:\\study\\empty D:\\study\\node_modules /purge;","text":"最近学习node.js，经常会遇到node_modules目录嵌套太深，无法删除的问题,后来在网上查了很长时间，终于解决了。 解决方法1.在要删除的文件夹目录下新建空白文件夹，如D:\\study\\empty;2.管理员方式打开命令行3.输入robocopy D:\\study\\empty D:\\study\\node_modules /purge;4.总结 robocopy empty_dir will_delete_dir /purge","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"Markdown基本语法","slug":"Markdom基本语法","date":"2016-12-13T12:52:50.000Z","updated":"2016-12-15T05:33:28.000Z","comments":true,"path":"2016/12/13/Markdom基本语法/","link":"","permalink":"http://yoursite.com/2016/12/13/Markdom基本语法/","excerpt":"Markdown 简明语法手册斜体和粗体","text":"Markdown 简明语法手册斜体和粗体 使用 * 和双星号左右包围文字，分别表示表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 示例： 123456# 这是一个一级标题## 这是一个二级标题### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 外链接使用[描述](链接地址) 为文字增加外链接。 示例： 这是去往本人博客的链接。 无序列表使用 *，+，- 表示无序列表。 示例： -无序列表项 一-无序列表项 二-无序列表项 三 有序列表使用数字和点表示有序列表。 示例： 1.有序列表项 一2.有序列表项 二3.有序列表项 三 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 行内代码块使用`代码` 表示行内代码块。 示例： 让我们聊聊html。 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 插入图像使用![描述](图片链接地址) 插入图像。 示例： Markdown高阶语法手册内容目录在段落中填写[TOC]以显示全文内容的目录结构。[TOC] 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 注脚使用 [^footnote]表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10));","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"Hexo搭建Github静态博客","slug":"Hexo搭建Github静态博客","date":"2016-12-13T12:49:13.000Z","updated":"2016-12-14T14:50:44.000Z","comments":true,"path":"2016/12/13/Hexo搭建Github静态博客/","link":"","permalink":"http://yoursite.com/2016/12/13/Hexo搭建Github静态博客/","excerpt":"环境安装Git安装node.js","text":"环境安装Git安装node.js 下载：http://nodejs.org/download/ 安装时直接保持默认配置即可。 配置Github建立Repository建立与你用户名对应的仓库，仓库名必须为【your_user_name.github.io】 配置SSH-Key安装Hexo关于Hexo的安装配置过程，请以官方Hexo【2】给出的步骤为准。 Installation打开Git命令行，执行如下命令 $ npm install -g hexo","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"git上传本地代码到GitHub","slug":"git上传本地代码到GitHUb","date":"2016-11-20T12:09:25.000Z","updated":"2017-07-01T12:20:53.235Z","comments":true,"path":"2016/11/20/git上传本地代码到GitHUb/","link":"","permalink":"http://yoursite.com/2016/11/20/git上传本地代码到GitHUb/","excerpt":"","text":"第一步：创建GitHub账户，下载git工具第二步：创建一个Repositories,复制https地址第三步：clone第二步https地址内容到本地 在本地新建一个文件夹，然后利用右键git bush（windows)或者cd 到当前文件夹（linux),在终端中输入以下命令：git clone https://https://github.com/dj940212/webApp.git 第五步：添加上传文件 将你要上传的project文件夹放到上一步新建的文件夹下面，之后输入下面命令：git add . //注意add后面有一个空格和. commit与push git initgit commit -m ‘stumansys’git remote add origin https://github.com/dj940212/webApp.gitgit push origin master输入你的username和password,然后等待上传就OK了。 dingjian","categories":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/categories/GitHub/"}],"tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]}]}